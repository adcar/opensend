<div class="upload-section">
  <div class="dropzone" id="dropzone">
    <div class="dropzone-content">
      <div class="dropzone-icon">
        <svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M24 32V16M24 16L18 22M24 16L30 22" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M8 32V36C8 38.2091 9.79086 40 12 40H36C38.2091 40 40 38.2091 40 36V32" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
      <h2 class="dropzone-title">Drop a file here</h2>
      <p class="dropzone-subtitle">or click to browse</p>
      <p class="dropzone-limit">Up to 10 MB</p>
    </div>
    
    <input type="file" id="file-input" class="file-input">
  </div>
  
  <div class="upload-progress" id="upload-progress" style="display: none;">
    <div class="upload-file-info" id="upload-file-info"></div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>
    <p class="progress-text" id="progress-text">Preparing...</p>
  </div>
</div>

<% if @documents.any? %>
  <div class="documents-section">
    <h2 class="section-title">Recent Files</h2>
    
    <div class="documents-grid">
      <% @documents.each do |doc| %>
        <%= link_to document_path(doc), class: "document-card" do %>
          <div class="file-icon">
            <%= render "shared/file_icon", document: doc %>
          </div>
          <div class="document-info">
            <h3 class="document-name"><%= doc.filename %></h3>
            <p class="document-meta"><%= doc.human_file_size %> Â· <%= time_ago_in_words(doc.created_at) %> ago</p>
          </div>
        <% end %>
      <% end %>
    </div>
  </div>
<% end %>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const dropzone = document.getElementById('dropzone');
  const fileInput = document.getElementById('file-input');
  const uploadProgress = document.getElementById('upload-progress');
  const uploadFileInfo = document.getElementById('upload-file-info');
  const progressFill = document.getElementById('progress-fill');
  const progressText = document.getElementById('progress-text');
  
  dropzone.addEventListener('click', () => fileInput.click());
  
  ['dragenter', 'dragover'].forEach(event => {
    dropzone.addEventListener(event, (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropzone.classList.add('dropzone-active');
    });
  });
  
  ['dragleave', 'drop'].forEach(event => {
    dropzone.addEventListener(event, (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropzone.classList.remove('dropzone-active');
    });
  });
  
  dropzone.addEventListener('drop', (e) => {
    if (e.dataTransfer.files.length > 0) {
      uploadFile(e.dataTransfer.files[0]);
    }
  });
  
  fileInput.addEventListener('change', (e) => {
    if (e.target.files.length > 0) {
      uploadFile(e.target.files[0]);
    }
  });
  
  function formatSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
  }
  
  async function uploadFile(file) {
    if (file.size > 10 * 1024 * 1024) {
      alert('File size exceeds 10 MB limit');
      return;
    }
    
    // Show progress UI
    dropzone.style.display = 'none';
    uploadProgress.style.display = 'block';
    uploadFileInfo.textContent = file.name + ' (' + formatSize(file.size) + ')';
    progressFill.style.width = '0%';
    progressText.textContent = 'Uploading...';
    
    const formData = new FormData();
    formData.append('file', file);
    
    // Use XMLHttpRequest for progress tracking
    const xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percent = Math.round((e.loaded / e.total) * 100);
        progressFill.style.width = percent + '%';
        progressText.textContent = 'Uploading... ' + percent + '%';
      }
    });
    
    xhr.addEventListener('load', () => {
      if (xhr.status === 201) {
        progressFill.style.width = '100%';
        progressText.textContent = 'Processing...';
        
        const data = JSON.parse(xhr.responseText);
        
        // Brief pause to show completion
        setTimeout(() => {
          progressText.textContent = 'Done! Redirecting...';
          setTimeout(() => {
            window.location.href = data.redirect_url;
          }, 500);
        }, 300);
      } else {
        let error = 'Upload failed';
        try {
          const data = JSON.parse(xhr.responseText);
          error = data.error || error;
        } catch (e) {}
        progressText.textContent = error;
        progressFill.style.background = '#8B2635';
      }
    });
    
    xhr.addEventListener('error', () => {
      progressText.textContent = 'Upload failed. Please try again.';
      progressFill.style.background = '#8B2635';
    });
    
    xhr.open('POST', '/documents');
    xhr.setRequestHeader('X-CSRF-Token', document.querySelector('meta[name="csrf-token"]').content);
    xhr.send(formData);
  }
});
</script>
